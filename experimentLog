2019年11月11日

Ubuntu 16 编译内核4.0.0成功，但装载后无法启动
内核4.17相比4.0变化太大
使用4.0.9，没有变化，且可以正确编译启动，但是鼠标会有些飘，可能内核4.x存在一些内部的问题
以后可以找找看能够兼容的最高版本号

---------------------------------------------------------------------------------------

编译内核：
sudo su
make mrproper
make clean
make menuconfig

make -j4
make modules_install
make install

---------------------------------------------------------------------------------------

kvm在宿主机中只是作为一个进程，它的多个vcup是作为线程被使用，因此其地址空间只有一个pte映射

----------------------------------------------------------------------------------------

使用docker测试一下

-----------------------------------------------------------------------------------------

/sys/kernel/mm/ksm/
/var/log/syslog

--------------------------------------------------------------------------------------

docker run --name my_nginx2 -d -p 8080:8088 -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro nginx

nginx 不太行啊 -> 用ab做一下压力测试

----------------------------------------------------------------------------------

redis是单进程单线程内存数据库，不行

-------------------------------------------------------------------------------------

elasticsearch基于filecache，不是匿名页面

------------------------------------------------------------------------------------
2019年12月16日 13点36分

测试pytorch dataloader
感觉可以，从windows来看应该确实是多线程读取
只不过需要先把数据集读到内存里再对内存数组进行loader封装，涉及两个问题：
1、python的list变量是否是分配了匿名页存储
2、loader是否共享映射（虽然python3-multiprocess的文档说是利用fork调用，但是其中细节并不了解）

----------------------------------------------------------------------------------------------------------------------
数据集记录

https://www.cnblogs.com/lifuyun/p/lifuyun2019060601.html NPL数据集
https://blog.csdn.net/qq_25819827/article/details/79048068 CV数据集


train-images.idx3-ubyte 和 train-labels.idx1-ubyte 来自 http://yann.lecun.com/exdb/mnist/ 手写字体图像识别数据集
training-parallel.tgz 来自 http://statmt.org/wmt11/translation-task.html#download 欧洲语言npl数据集

---------------------------------------------------------------------------------------------------------------------------------
2019年12月18日 12点26分

设计思路需要转变，之前钻牛角尖了，学长的设计还是妙啊
找工作集困难 -> 多进程共享内存（fork）少 -> 反向映射机制意义不大
但是我们的目的没有变：减少无用的操作，让每一次pte重定向都能够真实地释放物理页
所以即使有反向映射机制，优先级也应该是这样的：
只被单个pte映射的物理页 > 被多个pte映射的物理页 > 根本不存在的物理页（虚拟页扫描）

-------------------------------------------------------------------------------------------------------------------------------------------
虽然在写的时候把所有的ksm都改名成了pksm，
但是为了makefile和其他文件include方便（懒得一个个改了），
在放到项目里实际编译的时候还是要叫ksm

----------------------------------------------------------------------------------------------------
设置CONFIG_MEMORY_HOTREMOVE编译宏：
Processor type and feature -> *A*llow for memory hot remove

CONFIG_NUMA
Processor type and feature -> N*u*ma Memory Allocation and Scheduler Support

------------------------------------------------------------------------------------------------
mm/memory.c
    wp_page_copy
    do_anonymous_page
    do_cow_fault // 这个东西是对file cache用的 !vma_is_anonymous() -> do_fault() -> do_cow_fault()
mm/pksm.c
mm/page_alloc.c
    free_hot_cold_page
    #include <linux/ksm.h>   
include/linux/pksm.h
kernel/fork.c
    __mmput

--------------------------------------------------------------------------------------------------------------------

redis-benchmark -h 127.0.0.1 -p 6379 -n 100000000 script load "redis.call('LPUSH', 'list1', 'xxxxxx')"
redis-benchmark -h 127.0.0.1 -p 6379 -t lpush -n 100000000
sudo apt-get install redis-server



docker run -it -d -p 80:80  --name datahttpd -v /home/linux/website/:/usr/local/apache2/htdocs/ httpd



docker run --name my_nginx2 -d -p 82:80 -v /home/linux/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/linux/nginx/log:/var/log/nginx -v /home/linux/nginx/html:/usr/share/nginx/html nginx

docker run -d -v /home/linux/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/linux/nginx/log:/var/log/nginx -v /home/linux/nginx/html:/usr/share/nginx/html nginx


httperf --client=0/1 --server 127.0.0.1 --port 80 --uri /index.html --rate 100 --num-conn 500 --num-call 5 --timeout 5 
httperf --server 127.0.0.1 --port 80 --num-conns 20000 --rate 100 --timeout 2

docker stop $(docker ps -aq)

----------------------------------------------------------------------------------------------------------------------------------------
native_queued_spin_lock_slowpath 占cpu开销大

break_cow rmap_walk_ksm


------------------------------------------------------------

先确定 break_cow 触发的原因

再考虑解决：
    1、仿照ksm
    2、直接不处理

---------------------------------------------------------------

CONFIG_DEBUG_LOCKDEP

---------------------------------------------------------------
在华为云的arm服务器上编译
4.2 4.4 4.7不行

4.14 4.15 4.17 4.20.9可行

make ARCH_ENABLE_MEMORY_HOTPLUG=n -j2
---------------------------------------------------------------

4.2 -> 4.14

rmap_walk从返回int（RMAP系列宏）变为返回void
    可能是由于觉得没必要通过反向遍历的过程来指示结果成功与否
    结果是否成功通过遍历的效果就能判断（更直接）

rmap_one也从返回int（RMAP系列宏）变为返回bool
    反向映射的遍历过程中不使用这么多状态
    返回true表示操作成功，继续
    返回false表示操作失败，停止

---------------------------------------------------------------
sudo apt-get install gcc-aarch64-linux-gnu

编译busuBox
export ARCH=arm64
export CROSS_COMPILE=aarch64-linux-gnu-
#make menuconfig #P684，进行配置
make -j24 install

mkdir etc
mkdir dev
mkdir mnt
mkdir -p etc/init.d

创建 _install/etc/init.d/rcS
mkdir -p /proc
mkdir -p /tmp
mkdir -p /sys
mkdir -p /mnt
/bin/mount -a
mkdir -p /dev/pts
mount -t devpts devpts /dev/pts
echo /sbin/mdev > /proc/sys/kernel/hotplug
mdev -s

chmod +x _install/etc/init.d/rcS

创建 _install/etc/fstab
proc /proc proc defaults 0 0
tmpfs /tmp tmpfs defaults 0 0
sysfs /sys sysfs defaults 0 0
tmpfs /dev tmpfs defaults 0 0
debugfs /sys/kernel/debug debugfs defaults 0 0

创建 _install/etc/inittab
::sysinit:/etc/init.d/rcS
::respawn:-/bin/sh
::askfirst:-/bin/sh
::ctrlaltdel:/bin/umount -a -r

进入 _install/dev
sudo mknod console c 5 1
sudo mknod null c 1 3

编译内核
export ARCH=arm64
export CROSS_COMPILE=aarch64-linux-gnu-
#make vexpress_defconfig

make bzImage -j24 ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
make dtbs

qemu-system-arm -M vexpress-a9 -smp 4 -m 1024M -kernel arch/arm/boot/zImage -append "rdinit=/linuxrc console=ttyAMA0 loglevel=8" -dtb arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic
qemu-system-aarch64 -machine virt -cpu cortex-a57 -machine type=virt -nographic -m 2048 -smp 2 -kernel arch/arm64/boot/Image --append "rdinit=/linuxrc console=ttyAMA0"
qemu-system-aarch64 -machine virt -cpu cortex-a57 -machine type=virt -nographic -m 2048 -smp 2 -kernel arch/arm64/boot/Image --append “rdinit=/linuxrc console=ttyAMA0”


------------------------------------------------------------------------------
sudo ./qemu-1.7.0/arm-softmmu/qemu-system-arm  -M vexpress-a9 -kernel ./linux-3.10.28/arch/arm/boot/zImage -sd rootfs.img --append "root=/dev/mmcblk0 rw rootfs=ext3 rootdelay=3  physmap.enabled=0 console=ttyAMA0 console=tty0 kgdboc=tty0,115200 kgdbwait"  -net nic,vlan=0 -net tap,vlan=0  -serial tcp::4321,server

qemu-system-aarch64 -m 8192 -cpu cortex-a57 -smp 4 -M virt -bios QEMU_EFI.fd -nographic -drive if=none,file=ubuntu16.04-arm64.img,id=hd0 -device virtio-blk-device,drive=hd0 -s

-------------------------------------------------------------------------------------
按照《奔跑吧Linux内核》的方法搭建 qemu+gdb  成功，但是只能运行最小系统，没有上层环境，难以复现问题（相当于静态内核）
想要qemu+gdb运行Ubuntu，尝试qemu虚拟机运行aarch64的Ubuntu，失败

尝试kgdb，通过网络或串口等等
kvm不能直接连串口，qemu怎么设置tty不懂
最后的方法是在服务器上运行vmware

-------------------------------------------------------------------------------------
//建议打开的选项
(1)CONFIG_DEBUG_INFO = y 该选项可以使得编译的内核包含一些调试信息，使得调试更容易。
位置:---->Kernel hacking
   ---->Compile-time checks and compiler options
   ---->Compile the kernel with debug info
(2)CONFIG_FRAME_POINTER = y 该选项将使得内核使用帧指针寄存器来维护堆栈，从而就可以正确地执行堆栈回溯，即函数调用栈信息。
位置:---->Kernel hacking
   ---->Compile-time checks and compiler options
   ---->Compile the kernel with frame pointers
(3)CONFIG_MAGIC_SYSRQ = y (如果你选择了KGDB_SERIAL_CONSOLE,这个选项将自动被选上) 激活"魔术 SysRq"键. 该选项对kgdboc调试非常有用，kgdb向其注册了‘g’魔术键来激活kgdb 。  
位置:---->Kernel hacking
   ---->Magic SysRq key
当你想手动激活kgdb时，你可以触发SysRq的g键, 如:
$ echo"g">/proc/sysrq-trigger

//建议关闭的选项
(4)CONFIG_DEBUG_RODATA = n 该选项是将内核的一些内存区域空间设置为只读，这样可能导致kgdb的设置软断点功能失效。所以推荐将该选项关闭。  
位置:---->Kernel hacking
   ---->Write protect kernel read-only data structures
(5)CONFIG_DEBUG_SET_MODULE_RONX =n,该选项会将内核模块空间设置为只读，这样会导致调试内核模块时设置断点功能失效，设置断点时出现以下错误，(调试内核模块时吃过亏又重新编译的内核)所以将其关闭。
Cannot insert breakpoint 1.
Error accessing memory address 0xf90f6000: Unknown error -1.
位置：---->Kernel hacking
   ---->Set loadable kernel module data as NX and test as RO.
  
//必须使能的选项
(5)CONFIG_KGDB = y  
位置:---->Kernel hacking    
     ---->KGDB: kernel debugger
(6)CONFIG_KGDB_SERIAL_CONSOLE = y 使KGDB使用串口进行通信。
位置:---->Kernel hacking     
     ---->KGDB: kernel debugger              
     ---->KGDB: use kgdb over the serial console
(7)其余：
在Kernel hacking-->KGDB: kernel debugger目录下，除了KGDB：internal test suite外的选项全部使能y。

-------------------------------------------------------------------------------------
sudo vim /etc/default/grub
GRUB_CMDLINE_LINUX="rodata=off nokaslr kgdboc=ttyS0,115200"
sudo update-grub

target:
    echo g > /proc/sysrq-trigger

host:
    gdb ./vmlinux
    target remote /dev/ttyS0
    handle SIGSEGV noprint nostop pass
    break sys_clone
    c
    s

-------------------------------------------------------------------------------------
sudo vmrun stop "vmware/Target/Target.vmx" hard
sudo docker container prune