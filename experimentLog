2019年11月11日

Ubuntu 16 编译内核4.0.0成功，但装载后无法启动
内核4.17相比4.0变化太大
使用4.0.9，没有变化，且可以正确编译启动，但是鼠标会有些飘，可能内核4.x存在一些内部的问题
以后可以找找看能够兼容的最高版本号

---------------------------------------------------------------------------------------

编译内核：
sudo su
make mrproper
make clean
make menuconfig

make -j4
make modules_install
make install

---------------------------------------------------------------------------------------

kvm在宿主机中只是作为一个进程，它的多个vcup是作为线程被使用，因此其地址空间只有一个pte映射

----------------------------------------------------------------------------------------

使用docker测试一下

-----------------------------------------------------------------------------------------

/sys/kernel/mm/ksm/
/var/log/syslog

--------------------------------------------------------------------------------------

docker run --name my_nginx2 -d -p 8080:8088 -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro nginx

nginx 不太行啊 -> 用ab做一下压力测试

----------------------------------------------------------------------------------

redis是单进程单线程内存数据库，不行

-------------------------------------------------------------------------------------

elasticsearch基于filecache，不是匿名页面

------------------------------------------------------------------------------------
2019年12月16日 13点36分

测试pytorch dataloader
感觉可以，从windows来看应该确实是多线程读取
只不过需要先把数据集读到内存里再对内存数组进行loader封装，涉及两个问题：
1、python的list变量是否是分配了匿名页存储
2、loader是否共享映射（虽然python3-multiprocess的文档说是利用fork调用，但是其中细节并不了解）

----------------------------------------------------------------------------------------------------------------------
数据集记录

https://www.cnblogs.com/lifuyun/p/lifuyun2019060601.html NPL数据集
https://blog.csdn.net/qq_25819827/article/details/79048068 CV数据集


train-images.idx3-ubyte 和 train-labels.idx1-ubyte 来自 http://yann.lecun.com/exdb/mnist/ 手写字体图像识别数据集
training-parallel.tgz 来自 http://statmt.org/wmt11/translation-task.html#download 欧洲语言npl数据集

---------------------------------------------------------------------------------------------------------------------------------
2019年12月18日 12点26分

设计思路需要转变，之前钻牛角尖了，学长的设计还是妙啊
找工作集困难 -> 多进程共享内存（fork）少 -> 反向映射机制意义不大
但是我们的目的没有变：减少无用的操作，让每一次pte重定向都能够真实地释放物理页
所以即使有反向映射机制，优先级也应该是这样的：
只被单个pte映射的物理页 > 被多个pte映射的物理页 > 根本不存在的物理页（虚拟页扫描）

-------------------------------------------------------------------------------------------------------------------------------------------
虽然在写的时候把所有的ksm都改名成了pksm，
但是为了makefile和其他文件include方便（懒得一个个改了），
在放到项目里实际编译的时候还是要叫ksm

----------------------------------------------------------------------------------------------------
设置CONFIG_MEMORY_HOTREMOVE编译宏：
Processor type and feature -> *A*llow for memory hot remove

CONFIG_NUMA
Processor type and feature -> N*u*ma Memory Allocation and Scheduler Support

------------------------------------------------------------------------------------------------
mm/memory.c
    wp_page_copy
    do_anonymous_page
    do_cow_fault
mm/pksm.c
mm/page_alloc.c
    free_hot_cold_page
    #include <linux/ksm.h>   
include/linux/pksm.h
kernel/fork.c
    __mmput

--------------------------------------------------------------------------------------------------------------------

redis-benchmark -h 127.0.0.1 -p 6379 -n 100000000 script load "redis.call('LPUSH', 'list1', 'xxxxxx')"
redis-benchmark -h 127.0.0.1 -p 6379 -t lpush -n 100000000
sudo apt-get install redis-server



docker run -it -d -p 80:80  --name datahttpd -v /home/linux/website/:/usr/local/apache2/htdocs/ httpd



docker run --name my_nginx2 -d -p 82:80 -v /home/linux/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/linux/nginx/log:/var/log/nginx -v /home/linux/nginx/html:/usr/share/nginx/html nginx

docker run -d -v /home/linux/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/linux/nginx/log:/var/log/nginx -v /home/linux/nginx/html:/usr/share/nginx/html nginx


httperf --client=0/1 --server 127.0.0.1 --port 80 --uri /index.html --rate 100 --num-conn 500 --num-call 5 --timeout 5 
httperf --server 127.0.0.1 --port 80 --num-conns 20000 --rate 100 --timeout 2

docker stop $(docker ps -aq)

----------------------------------------------------------------------------------------------------------------------------------------
native_queued_spin_lock_slowpath 占cpu开销大

break_cow rmap_walk_ksm


------------------------------------------------------------

先确定 break_cow 触发的原因

再考虑解决：
    1、仿照ksm
    2、直接不处理

---------------------------------------------------------------

CONFIG_DEBUG_LOCKDEP

---------------------------------------------------------------
在华为云的arm服务器上编译
4.2 4.4 4.7不行

4.14 4.15 4.17 4.20.9可行

make ARCH_ENABLE_MEMORY_HOTPLUG=n -j2
---------------------------------------------------------------

4.2 -> 4.14

rmap_walk从返回int（RMAP系列宏）变为返回void
    可能是由于觉得没必要通过反向遍历的过程来指示结果成功与否
    结果是否成功通过遍历的效果就能判断（更直接）

rmap_one也从返回int（RMAP系列宏）变为返回bool
    反向映射的遍历过程中不使用这么多状态
    返回true表示操作成功，继续
    返回false表示操作失败，停止